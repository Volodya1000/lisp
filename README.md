# Семантический анализ и построение AST

Модуль семантического анализа преобразует сырое дерево разбора (Parse Tree), полученное от парсера ANTLR, в типизированное абстрактное синтаксическое дерево (AST). Класс `SemanticAnalyzer` наследует `lispVisitor` и выполняет рекурсивный обход узлов. В отличие от синтаксического разбора, данный этап работает со смысловой нагрузкой кода: проверяет существование переменных, валидирует сигнатуры вызовов и, что критически важно, формирует карту памяти для будущего этапа компиляции.

### Типы узлов AST

Результирующее дерево строится из строго типизированных структур (dataclasses), каждая из которых представляет конкретную семантическую конструкцию:
*   **Литералы:** `NumberNode`, `StringNode`, `NilNode`, `TrueNode` и `SymbolNode`.
*   **Списки и вызовы:** `ListNode` для структур данных и `CallNode` для вызова пользовательских функций. Встроенные примитивы (например, `+` или `cons`) оборачиваются в специализированный `PrimCallNode`, что упрощает их трансляцию в нативные инструкции WASM.
*   **Управляющие конструкции:** `CondNode` (хранит список пар «условие-тело»), `PrognNode` (последовательное выполнение).
*   **Определения:** `DefunNode` и `LambdaNode`. Последний сохраняет не только параметры и тело, но и ссылку на захваченное лексическое окружение.

### Таблица символов и управление окружением

Ключевым компонентом анализа является класс `Environment`, реализующий иерархическую структуру областей видимости. Каждый экземпляр окружения хранит ссылку на родителя (`parent`), образуя цепочку от текущего блока до глобального контекста.

Информация об идентификаторах инкапсулирована в класс `SymbolInfo`. Помимо метаданных (флаги `is_function`, `is_primitive`), он содержит данные, определяющие физическое расположение переменных в памяти:
*   `env_level`: Глубина вложенности (0 для глобального уровня, 1+ для локальных).
*   `var_index`: Порядковый номер переменной внутри текущего кадра стека.

**Расчет смещений (Layout)**
При определении переменной через метод `define` анализатор проверяет уровень вложенности. Если переменная локальная, ей присваивается уникальный инкрементальный индекс `var_index`. Фактически, именно на этапе семантического анализа определяется раскладка стекового кадра (Stack Frame Layout). Этот индекс впоследствии используется генератором кода для вычисления точного смещения в байтах относительно начала фрейма в куче.

**Разрешение имен**
Метод `resolve` реализует поиск идентификатора: сначала в текущей таблице символов, затем рекурсивно в родительских окружениях. Это позволяет корректно идентифицировать свободные переменные (free variables), которые необходимо захватить в замыкание.

### Архитектура обработчиков (Handlers)

Логика анализа разбита на независимые модули, наследующие `SpecialFormHandler`. Главный класс анализатора выступает диспетчером: при встрече списка, начинающегося с ключевого слова (например, `cond` или `defun`), управление передается соответствующему компоненту.

Примеры реализации логики:
*   **SetqHandler:** Проверяет типы аргументов и регистрирует переменную в текущем окружении, если она не была определена ранее.
*   **LambdaHandler и DefunHandler:** Управляют созданием новых областей видимости. Перед анализом тела функции создается новый `Environment`, в котором регистрируются параметры аргументов. Результатом становится узел AST, хранящий ссылку на это окружение.
*   **LetHandler:** Реализует конструкцию `let` через трансформацию AST (Desugaring). Вместо создания специфического узла, обработчик преобразует `let` в вызов анонимной функции (IIFE). Список связываний трансформируется в параметры и аргументы `CallNode`, обертывающего `LambdaNode`.

Для обработки цитируемых данных (`quote`) используется отдельный класс `QuoteBuilder`, который строит структуру AST без выполнения семантических проверок, трактуя содержимое как данные, а не как код.

### Диагностика ошибок

Система валидации построена на классе `ErrorCollector`, который накапливает ошибки без прерывания процесса анализа. Это позволяет выявить множество проблем за один проход.

Ошибки типизированы:
1.  **ArityError:** Несоответствие числа аргументов (например, `defun` без тела).
2.  **TypeMismatchError:** Использование узла неверного типа (например, передача атома вместо списка связываний в `let`).
3.  **InvalidSyntaxError:** Структурные нарушения специальных форм.

Коллектор поддерживает **стек контекста**. При входе в функцию или сложную конструкцию анализатор добавляет метку в стек. Если внутри возникает ошибка, она сохраняет всю цепочку вложенности (например, "Function 'calculate' -> Cond Clause #2"), что обеспечивает точную локализацию проблемы.
# Архитектура и устройство компилятора

Компилятор представляет собой транслятор AST → WAT, реализующий паттерн Visitor. Процесс трансляции разделен на две фазы: предварительное сканирование для регистрации глобальных определений и генерация инструкций.

Архитектура построена на строгом разделении ответственности: логика обхода узлов AST и генерации кода сосредоточена в классе `WasmCompiler`, тогда как все изменяемое состояние вынесено в класс `CompilerContext`. Именно `Context` управляет таблицами символов (`Environment`), списками глобальных переменных и реестром типов, что позволяет поддерживать чистоту процесса рекурсивного спуска. Результатом работы является единый модуль WebAssembly, включающий таблицу функций, конфигурацию памяти, импорты хост-системы и скомпилированный байт-код.

### Управление памятью и представление данных

Для упрощения системы типов все значения в скомпилированном модуле — числа, логические значения и указатели памяти — унифицированы и передаются как числа с плавающей точкой (`f64`). При адресации памяти производится явное приведение типов (`f64` ↔ `i32`).

Модель памяти построена на стратегии последовательного выделения. Глобальная переменная `$heap_ptr` хранит адрес начала свободной области. Выделение памяти происходит максимально просто: текущее значение указателя возвращается как адрес нового объекта, а сам указатель увеличивается на размер этого объекта. Освобождение памяти в текущей реализации не предусмотрено.

Структуры данных в куче имеют следующую организацию:
*   **Cons-ячейка:** Занимает 16 байт (два слота `f64` для `car` и `cdr`).
*   **Строка:** Хранится как непрерывный блок памяти. Первые 4 байта содержат длину строки (тип `i32`), а сразу за ними следуют байты символов в кодировке UTF-8.
*   **Фрейм окружения:** Блок памяти, содержащий значения локальных переменных функции. Также хранит ссылку на окружение родительской функции.

### Лямбда-выражения и замыкания

Поддержка лямбда-функций реализована через передачу окружения. Каждая лямбда компилируется в отдельную процедуру WebAssembly, принимающую скрытый первый аргумент `$env` — указатель на захваченный контекст.

**Доступ к переменным**
Доступ к переменным осуществляется статически. Локальные переменные берутся по фиксированному смещению в текущем фрейме. Если переменная находится во внешней функции (замыкание), компилятор генерирует код, который проходит по цепочке родительских окружений. Инструкции последовательно загружают ссылки на предыдущие фреймы (от текущего к родителю, от родителя к дедушке), пока не будет достигнута нужная область видимости.

В памяти замыкание представляется как cons-ячейка:
*   `car`: индекс функции в таблице косвенных вызовов (Table).
*   `cdr`: указатель на текущее окружение.

Вызовы производятся через инструкцию `call_indirect`. Рантайм извлекает индекс и среду из замыкания, передавая их целевой процедуре. Поскольку WebAssembly требует строгого соответствия типов, компилятор динамически отслеживает сигнатуры вызовов и генерирует необходимые определения типов (`type`) в заголовке модуля.

### Компоненты системы

**WasmCompiler**
Центральный класс-посетитель. Управляет обходом узлов AST, определяет структуру итогового модуля (порядок секций) и транслирует языковые конструкции (`defun`, `if`, `setq`) в инструкции WAT.

**CompilerContext**
Инкапсулирует изменяемое состояние компиляции: таблицы символов, списки глобальных переменных и реестр индексов для таблицы косвенных вызовов (`table_entries`). Отвечает за генерацию уникальных имен для анонимных лямбд и отслеживание глубины стека.

**FramePolicy**
Отвечает за низкоуровневую арифметику указателей внутри стекового кадра в куче. Рассчитывает смещения (оффсеты) в байтах для доступа к локальным переменным и ссылке на родительское окружение, скрывая детали выравнивания памяти от основной логики.

**WasmStdLib**
Данный класс предоставляет статическую библиотеку времени исполнения (Runtime System), реализующую функциональность, отсутствующую в базовом наборе инструкций WebAssembly. В первую очередь здесь определены функции работы с динамической памятью: $std_cons для выделения места под новую пару (ячейку списка), а также $std_car и $std_cdr для чтения головы и хвоста списка по указателю. Также библиотека содержит реализацию алгоритма $std_equal для глубокого рекурсивного сравнения сложных структур данных и функцию $std_str_concat, которая вычисляет размеры строк и создает новый строковый объект в куче. Помимо логики, класс содержит декларации импорта внешних функций ввода-вывода (печать, чтение) и инициализирует глобальные переменные.

**PrimitiveHandler**
Транслятор встроенных операций (математика, логика, ввод-вывод). Преобразует высокоуровневые примитивы либо в нативные опкоды WebAssembly, либо в вызовы функций стандартной библиотеки.

**TypeRegistry**
Менеджер системы типов. Отслеживает количество аргументов всех вызываемых функций и формирует корректные сигнатуры для секции `type` в WASM-модуле. Это необходимо для валидации инструкций `call_indirect` виртуальной машиной.

**WatBuilder**
Инструмент для генерации S-выражений. Упрощает формирование корректного текста WAT, автоматически управляя вложенностью блоков (`block`, `loop`, `if`) и гарантируя правильную расстановку скобок в выходном файле.
