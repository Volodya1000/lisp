# Семантический анализ и построение AST

Модуль семантического анализа преобразует сырое дерево разбора (Parse Tree), полученное от парсера ANTLR, в типизированное абстрактное синтаксическое дерево (AST). Класс `SemanticAnalyzer` наследует `lispVisitor` и выполняет рекурсивный обход узлов. В отличие от синтаксического разбора, данный этап работает со смысловой нагрузкой кода: проверяет существование переменных, валидирует сигнатуры вызовов и, что критически важно, формирует карту памяти для будущего этапа компиляции.

### Типы узлов AST

Результирующее дерево строится из строго типизированных структур (dataclasses), каждая из которых представляет конкретную семантическую конструкцию:
*   **Литералы:** `NumberNode`, `StringNode`, `NilNode`, `TrueNode` и `SymbolNode`.
*   **Списки и вызовы:** `ListNode` для структур данных и `CallNode` для вызова пользовательских функций. Встроенные примитивы (например, `+` или `cons`) оборачиваются в специализированный `PrimCallNode`, что упрощает их трансляцию в нативные инструкции WASM.
*   **Управляющие конструкции:** `CondNode` (хранит список пар «условие-тело»), `PrognNode` (последовательное выполнение).
*   **Определения:** `DefunNode` и `LambdaNode`. Последний сохраняет не только параметры и тело, но и ссылку на захваченное лексическое окружение.

### Таблица символов и управление окружением

Ключевым компонентом анализа является класс `Environment`, реализующий иерархическую структуру областей видимости. Каждый экземпляр окружения хранит ссылку на родителя (`parent`), образуя цепочку от текущего блока до глобального контекста.

Информация об идентификаторах инкапсулирована в класс `SymbolInfo`. Помимо метаданных (флаги `is_function`, `is_primitive`), он содержит данные, определяющие физическое расположение переменных в памяти:
*   `env_level`: Глубина вложенности (0 для глобального уровня, 1+ для локальных).
*   `var_index`: Порядковый номер переменной внутри текущего кадра стека.

**Расчет смещений (Layout)**
При определении переменной через метод `define` анализатор проверяет уровень вложенности. Если переменная локальная, ей присваивается уникальный инкрементальный индекс `var_index`. Фактически, именно на этапе семантического анализа определяется раскладка стекового кадра (Stack Frame Layout). Этот индекс впоследствии используется генератором кода для вычисления точного смещения в байтах относительно начала фрейма в куче.

**Разрешение имен**
Метод `resolve` реализует поиск идентификатора: сначала в текущей таблице символов, затем рекурсивно в родительских окружениях. Это позволяет корректно идентифицировать свободные переменные (free variables), которые необходимо захватить в замыкание.

### Архитектура обработчиков (Handlers)

Логика анализа разбита на независимые модули, наследующие `SpecialFormHandler`. Главный класс анализатора выступает диспетчером: при встрече списка, начинающегося с ключевого слова (например, `cond` или `defun`), управление передается соответствующему компоненту.

Примеры реализации логики:
*   **SetqHandler:** Проверяет типы аргументов и регистрирует переменную в текущем окружении, если она не была определена ранее.
*   **LambdaHandler и DefunHandler:** Управляют созданием новых областей видимости. Перед анализом тела функции создается новый `Environment`, в котором регистрируются параметры аргументов. Результатом становится узел AST, хранящий ссылку на это окружение.
*   **LetHandler:** Реализует конструкцию `let` через трансформацию AST (Desugaring). Вместо создания специфического узла, обработчик преобразует `let` в вызов анонимной функции (IIFE). Список связываний трансформируется в параметры и аргументы `CallNode`, обертывающего `LambdaNode`.

Для обработки цитируемых данных (`quote`) используется отдельный класс `QuoteBuilder`, который строит структуру AST без выполнения семантических проверок, трактуя содержимое как данные, а не как код.

### Диагностика ошибок

Система валидации построена на классе `ErrorCollector`, который накапливает ошибки без прерывания процесса анализа. Это позволяет выявить множество проблем за один проход.

Ошибки типизированы:
1.  **ArityError:** Несоответствие числа аргументов (например, `defun` без тела).
2.  **TypeMismatchError:** Использование узла неверного типа (например, передача атома вместо списка связываний в `let`).
3.  **InvalidSyntaxError:** Структурные нарушения специальных форм.

Коллектор поддерживает **стек контекста**. При входе в функцию или сложную конструкцию анализатор добавляет метку в стек. Если внутри возникает ошибка, она сохраняет всю цепочку вложенности (например, "Function 'calculate' -> Cond Clause #2"), что обеспечивает точную локализацию проблемы.

# Архитектура и устройство компилятора

Компилятор представляет собой модульный транслятор AST → WAT, реализующий паттерн Visitor. Процесс трансляции сохраняет двухфазный подход (сканирование определений и генерация кода), но внутренняя структура была подвергнута глубокому рефакторингу для устранения антипаттерна "God Object" и повышения поддерживаемости кода.

Архитектура построена на **декомпозиции ответственности**: класс `WasmCompiler` выступает в роли высокоуровневого фасада и диспетчера, делегируя конкретную логику генерации кода специализированным обработчикам (**Handlers**). Изменяемое состояние (таблицы символов, счетчики, флаги) изолировано в классе `CompilerContext`.

### Управление памятью и представление данных

Система типов унифицирована: все значения Lisp (числа, логические значения, указатели) передаются как `f64`. При работе с памятью применяются строгие типизированные константы и явные преобразования (`f64` ↔ `i32`) через `OpCode.TRUNC_U` и `OpCode.CONVERT_U`, что исключает использование "магических строк" в коде генерации.

Модель памяти опирается на последовательное выделение (bump pointer allocation). Глобальная переменная `$heap_ptr` указывает на свободную область. Константы разметки памяти (размер машинного слова, заголовки объектов) вынесены в статический класс `MemoryLayout`.

Структуры данных в куче:
*   **Cons-ячейка:** 16 байт (два слова по 8 байт).
*   **Строка:** 4 байта длины (`i32`) + тело строки (UTF-8 байты).
*   **Фрейм окружения:** Блок памяти, хранящий ссылку на родительское окружение (Static Link) и значения локальных переменных.

### Лямбда-выражения и замыкания

Поддержка функций первого класса реализована через передачу окружения. Любая функция (именованная или анонимная) компилируется в процедуру WASM, принимающую скрытый аргумент `$env`.

**Доступ к переменным**
Логика доступа к переменным полностью инкапсулирована в `FramePolicy` и `VariableHandler`. Компилятор статически рассчитывает "расстояние" до переменной (разницу уровней вложенности). Если переменная находится в замыкании, `FramePolicy` генерирует цепочку инструкций для прохода по ссылкам родительских фреймов в куче, скрывая от основной логики низкоуровневую арифметику указателей.

В рантайме замыкание — это пара (cons-ячейка):
*   `car`: индекс функции в таблице `Table`.
*   `cdr`: указатель на захваченное окружение.

Вызовы осуществляются через `call_indirect`. Динамическая проверка сигнатур обеспечивается через `TypeRegistry`, который регистрирует типы функций "на лету".

### Компоненты системы

**WasmCompiler (Facade)**
Точка входа и диспетчер. Он реализует интерфейс `ASTVisitor`, но не содержит логики генерации кода. Его задача — маршрутизировать узлы AST в соответствующие хендлеры и собрать итоговый модуль из секций.

**CompilerContext**
Центральное хранилище состояния. Содержит:
*   `Environment` (текущие области видимости).
*   `TypeRegistry` (реестр сигнатур функций).
*   Списки глобальных переменных и таблицу функций (`table_entries`).
*   Ссылки на активные хендлеры для перекрестного взаимодействия.

**Handlers (Обработчики)**
Группа классов, разделяющих логику компиляции по доменным областям:
*   **`FunctionHandler`**: Отвечает за `defun`, `lambda` и вызовы функций (`call`). Управляет генерацией пролога функции, аллокацией фреймов и созданием замыканий.
*   **`ControlFlowHandler`**: Генерация управляющих конструкций: `if`, `cond`, логических операторов (`and`/`or`) и блоков `progn`.
*   **`VariableHandler`**: Обработка чтения (`SymbolNode`) и записи (`SetqNode`) переменных. Взаимодействует с `FramePolicy` для вычисления адресов.
*   **`ValueHandler`**: Генерация кода для литералов: чисел, строк, списков и квотированных выражений (`quote`).

**FramePolicy**
Абстракция над физическим устройством стекового кадра в куче. Отвечает за:
*   Расчет размера фрейма.
*   Вычисление смещений (offset) для переменных.
*   Генерацию WAT-кода для доступа к переменным по цепочке статических ссылок (static chain traversal).

**WasmStdLib**
Статическая библиотека времени исполнения (Runtime). Реализует базовые примитивы, которые невозможно или неэффективно выразить чистым байт-кодом на каждом шаге: аллокация памяти (`$std_cons`), доступ к спискам (`$std_car`, `$std_cdr`), глубокое сравнение (`$std_equal`) и конкатенация строк.

**WasmTypes & OpCodes**
Набор констант и перечислений (Enum), заменяющий использование строковых литералов. Гарантирует строгую типизацию инструкций генератора (например, использование `OpCode.ADD` вместо строки `'f64.add'`).

**WatBuilder**
Инструмент для генерации S-выражений. Предоставляет удобный API для эмиссии инструкций и управления вложенностью блоков (`if`, `block`, `loop`) через контекстные менеджеры Python (`with wb.if_block(): ...`).